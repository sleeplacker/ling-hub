## 1 图的表示

图的表示主要有**邻接链表**和**邻接矩阵**，两种表示法的既能表示无向图，也能表示有向图。

邻接链表通常用于表示**稀疏图**(边的条数$|E|$远远小于定点数的二次方$|V|^2$的图)。

邻接矩阵通常用于表示**稠密图**(边的条数$|E|$接近定点数的二次方$|V|^2$的图)

> 对于图 $G=(V,E)$ 来说，其**邻接链表表示**由一个包含 $|V|$ 条链表的数组 $Adj$ 所构成，每个结点有一条链表。对于每个结点 $u\in V$，邻接链表 $Adj[u]$ 包含所有与结点 $u$ 之间有边相连的结点 $v$，即 $Adj[u]$ 包含图 $G$ 中所有与 $u$ 邻接的结点(也可以说，该链表里包含指向这些结点的指针)。
>
> 对于**邻接矩阵表示**来说，我们通常会将图 $G$ 中的结点编号为 $1,2, ... , |V|$，这种编号可以是任意的。在进行此种编号之后，图 $G$ 的邻接矩阵表示由一个 $|V| \times|V|$ 的矩阵 $A=(a_{ij})$ 予以表示，该矩阵满足下述条件：
>
> $a_{ij}=\left\{\begin{array} \\1 & 若 (i,j)\in E \\0 & 其他 \end{array} \right.$

下图展示了**无向图**的两种表示法，图(b)为邻接链表，图(c)为邻接矩阵。

- 在无向图的邻接链表表示中，链表总长度=2|E|，因为每条边会出现在两个顶点的链表中。
- 在无向图的邻接矩阵表示中，不管一个图有多少条边，空间需求皆为 $\Theta(V^2)$。

![UndirectedGraphRepresentation](../static/image/UndirectedGraphRepresentation.png)



下图展示了**有向图**的两种表示法，图(b)为邻接链表，图(c)为邻接矩阵。

- 在有向图的邻接链表表示中，链表总长度=|E|，因为每条边只出现在一个顶点的链表中。
- 与无向图一样，在有向图的邻接矩阵表示中，不管一个图有多少条边，空间需求皆为 $\Theta(V^2)$。

![DirectedGraphRepresentation](../static/image/DirectedGraphRepresentation.png)



**权重图的表示**

> 邻接链表表示：设 $G=(V,E)$ 为一个权重图，其权重函数为 $w$，我们可以直接将边 $(u,v) \in E$ 的权重值 $w(u,v)$ 存放在结点 $u$ 的邻接链表里。例如在上图(b)中，边 $(1,2)$ 的权重为 $w_1$，就将结点 1 的链表中的结点 2 的权重属性设置为 $w_1$。
>
> 邻接矩阵表示：如果 $G = (V,E)$ 为一个权重图，其权重函数为 $w$，则我们直接将边 $(u,v) \in E$ 的权重 $w(u,v)$ 存放在邻接矩阵中第 $u$ 行第 $v$ 列记录上。对于不存在的边，则在相应的行列记录上存放指 $NIL$。不过，对于许多问题来说，用 0 或 $\infty$ 来表示一条不存在的边可能更为便捷。



## 2 广度优先搜索

> 给定图 $G=(V,E)$ 和一个可以识别的源节点 $s$，**广度优先搜索**对图 $G$ 中的边进行系统性的探索来发现可以从源节点 $s$ 到达所有结点。该算法能够计算从源节点 $s$ 到每个可到达的结点的距离(最少的边数)，同时生成一棵“广度优先搜索树”。该树以源结点 $s$ 为根结点，包含所有可以从 $s$ 到达的结点。对于每个从源结点 $s$ 可以到达的结点 $v$，在广度优先搜素树里从结点 $s$ 到结点 $v$ 的简单路径所对应的就是图 $G$ 中从结点 $s$ 到结点 $v$ 的“最短路径”，即包含最少边树的路径。该算法既可以用于有向图，也可以用于无向图。

广度优先搜索(Breadth-First-Search BFS)过程

![BFS](../static/image/BFS.png)

如上图所示：BFS算法借助先进先出队列 $Q$ 来保存要访问的结点(灰色结点)。初始时 Q 中只包含源结点 $s$，且 $s.d = 0$，然后总是从队列头取出一个结点 $u$，然后访问该结点的邻接结点 $v$ ，且置 $v.d = s.d + 1$，并将 $v$ 加入队列 $Q$，然后从队列 $Q$ 中删除结点 $u$ (黑色结点)；然后从发上面的过程，假设当前访问的是结点 $u$ 的邻接点 $v$，则 $v.d = u.d+1$；最终队列 Q 中不再有结点时算法结束。

广度优先搜索的结果可能依赖于对每个结点的邻接点的访问顺序：广度优先搜索树可能不一样，但本算法所计算出来的距离 d 都是一样的。

**BFS算法时间复杂度**：$\Omicron(V+E)$



**最短路径**

> 我们定义从源结点 $s$ 到结点 $v$ 的**最短路径距离** $\delta(s,v)$ 为从结点 $s$ 到结点 $v$ 之间所有路径里面最少的边数。如果从结点 $s$ 到结点 $v$ 之间没有路径，则 $\delta(s,v) = \infty$。我们称从结点 $s$ 到结点 $v$ 的长度为 $\delta(s,v)$ 的路径为 $s$ 到 $v$ 的**最短路径**。

**BFS算法和最短路径的关系**

对于有向图或者无向图 $G=(V,E)$，对于所有的 $v \in V$，$v.d=\delta(s,v)$，其中 $s$ 为源结点。

构造最短路径：结点 $s$ 到结点 $v$ 的最短路径可以通过不断访问结点 $v$ 的 $\pi$ 属性来构造，例如边$(v.\pi,v)$是最短路径中的一条边，$(v.\pi.\pi, v.\pi)$也是最短路径中的一条边，以此类推，直到访问到源结点 $s$，整条最短路径就被构造出来了。

**广度优先树**

> 对于图 $G=(V,E)$ 和源结点 $s$，我们定义图 $G$ 的**前驱子图**为 $G_\pi = (V_\pi,E_\pi)$，其中 $V_\pi=\{v\in V: v.\pi\neq NIL\} \bigcup \{s\}$，$E_\pi=\{(v.\pi,v): v\in V_\pi-\{s\}\}$
>
> 当运行在一个有向图或无向图 $G=(V,E)$ 上时，BFS 过程所建造出来的 $\pi$ 属性使得前驱子图 $G_\pi=(V_\pi,E_\pi)$ 成为一棵广度优先树。

