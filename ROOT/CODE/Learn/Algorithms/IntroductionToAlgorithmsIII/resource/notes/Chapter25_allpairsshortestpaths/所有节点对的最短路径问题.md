## 0 简介

**问题描述**

> 给定一个带权重的有向图 $G=(V,E)$，其权重函数为 $w: E\rightarrow R$，该函数将边映射到实数值的权重上。我们希望找到，对于所有的结点对$u, v\in V$，一条从结点 $u$ 到结点 $v$ 的最短路径，其中一条路径的权重为组成该路径的所有边的权重之和。
>
> 我们通常希望以表格的形式来表示输出：第 $u$ 行 第 $v$ 列给出的是结点 $u$ 到结点 $v$ 的最短路径权重。

**传统方法**

> 我们可以通过运行|V|次单源最短路径算法来解决所有结点对之间的最短路径问题，每一次使用一个不同的结点作为源结点。如果所有的边的权重为非负值，那么可以使用 Dijkstra 算法，否则我们必须使用效率更低的 Bellman-Ford 算法。
>
> - 如果能使用 Dijkstra 算法，则时间复杂度取决于最小优先队列的实现：
>
>   数组：$\Omicron(V^3+VE) = \Omicron(V^3)$
>
>   二叉堆：$\Omicron(VE\space \lg V)$
>
>   斐波那契堆：$\Omicron(V^2\space \lg V+VE)$
>
> - 如果使用 Bellman-Ford 算法：
>
>   时间复杂度为 $\Omicron(V^2E)$，在稠密图的情况下，为 $\Omicron(V^4)$
>
> 本章将介绍比上面两种算法更快的算法。

**权重矩阵**

> 算法的输入通常是一个 $n \times n$ 的矩阵 $W$，该矩阵代表的是一个由 $n$ 个结点的有向图 $G=(V, E)$ 的边的权重。也就是说，$W=(w_{ij})$，其中
>
> $w_{ij} = \left\{\begin{array} \\ 0 & 若\space i=j \\ 有向边(i,j)的权重 & 若 \space i \neq j \space 且(i,j) \in E \\ \infty & 若 \space i\neq j \space  且(i,j)\notin E \end{array}\right.$

## 1 最短路径和矩阵乘法

**算法思路浅析**

如下图所示，$L^{(1)}$ 表示包含1条边的最短路径；$L^{(2)}$ 表示包含2条边的最短路径，如果 $L^{(2)}$ 矩阵中某个位置有更小的值，则覆盖 $L^{(1)}$ 中那个位置的值；$L^{(3)}$ 和 $L^{(4)}$ 也做类似操作。由于包含 $n$ 个结点的图的最短路径最多包含 $n-1$ 条边，所以由于下图包含5个结点，所以只需要求包含4条边的最短路径即可，即 $L^{(4)}$ 就是最终解。

![AllPairs1](../static/image/AllPairs1.png)

**时间复杂度**

$\Theta(V^4)$

然而，可以对算法进行改进，仅用 $\lceil\lg (n-1)\rceil$ 个矩阵乘积来计算 $L^{(n-1)}$，改进后的时间复杂度为

$\Theta(V^3 \lg V)$



## 2 Floyd-Warshall(弗洛伊德) 算法

**算法条件**

可以存在负权重的边，但是不能存在权重为负的环路；可以看出条件比较宽松，类似 Bellman-Ford 算法的条件。

**算法关键思想**

对任意两个结点间的最短路径，从没有中间结点的情况开始，不断扩大中间结点的范围，直到中间结点的范围达到图的所有结点。

如下图所示，对于任意结点对 $i$ 和 $j$，我们首先求 $i$ 和 $j$ 之间不包含任何中间结点的情况，即最短路径 $\delta(i, j)= w(i, j)$，然后我们逐渐尝试扩大中间结点的范围，例如我们允许 $i$ 和 $j$ 之间可以包含 $\{k\}$，那么可能存在路径 $i\leadsto k$ 和 路径 $k\leadsto j$，假如都存在，那么 $\delta(i, j)$ 就被更新为 $w(i, j)$ 与 $\delta(i, k)+\delta(k,j)$ 之间较小的一个；当然，虽然 $i$ 和 $j$ 之间可以包含 $\{k\}$，但是不一定包含 $k$，即不同时存在路径 $i\leadsto k$ 和 路径 $k\leadsto j$，那么 $\delta(i, j)$ 就不被更新，依然等于 $w(i,j)$。然后，我们再加入一个允许的中间结点 $l$，即允许 $i$ 和 $j$ 之间可以包含 $\{k, l\}$，我们可以做同样的比较和选择，且由于前面已经求出了包含 $\{k\}$ 的情况的最短路径，当加入 $l$ 时，需要比较的数据都已经计算过并保存了，所以能使用自底向上的动态规划方法。然后我们重复上面的过程，直到允许 $i$ 和 $j$ 之间允许的中间结点为图中的全部结点，即 $V$，这样就求出了最终结果。

上面的描述可以表示为下面的公式

> $d^{(k)}_{ij}=\left\{\begin{array} \\w_{ij} & 若 \space k=0 \\min(d^{(k-1)}_{ij},d^{(k-1)}_{ik}+d^{(k-1)}_{kj}) & 若\space k\geqslant 1\end{array}\right.$ 

![FloydMiddleVertex](../static/image/FloydMiddleVertex.png)

**算法执行步骤**

1.  $D^{(0)}$ 表示不存在中间结点的情况，这时刚好等于图的权重矩阵 $W$
2. $D^{(1)}$ 表示最短路径可以包含中间结点 $\{v_1\}$ 的情况，由于求解 $D^{(1)}$ 只需依赖 $D^{(0)}$，而 $D^{(0)}$ 已在第 1 步中求解，所以 $D^{(1)}$ 也能顺利求解
3. $D^{(2)}$ 表示最短路径可以包含中间结点 $\{v_1, v_2\}$ 的情况，同样，由于求解 $D^{(2)}$ 只需依赖 $D^{(1)}$，而 $D^{(1)}$ 已在第 2 步中求解，所以 $D^{(2)}$ 也能顺利求解
4. $D^{(3)}$、$D^{(4)}$ 和 $D^{(5)}$ 也同理可以求解，由于 $D^{(5)}$ 已经允许中间结点包含了所有结点(即 $V$)，所以算法在此结束

另外，在算法执行的同时，还在不断更新前驱矩阵 $\Pi$，以构造前驱子图。

![FloydSteps](../static/image/FloydSteps.png)

**Floyd-Warshall 算法的时间复杂度**

$\Theta(V^3)$

**Floyd-Warshall 算法的应用-有向图的传递闭包**

> 给定有向图 $G=(V, E)$，结点集合为 $V=\{1,\space 2,\space  ..., \space  n\}$，我们希望判断对于所有的结点对 $i$ 和 $j$，图 $G$ 是否包含一条结点 $i$ 到结点 $j$ 的路径。我们定义图 $G$ 的**传递闭包**为 $G^*=(V, E^*)$，其中 $E^*=\{(i, j): \space 如果图 G 中包含一条从结点 i 到结点 j 的路径\}$。

我们可以使用 Floyd-Warshall 算法来求解传递闭包，如上面的矩阵图中，最终求解结果为 $D^{(5)}$，该矩阵中如果第 $i$ 行，第 $j$ 列位置的值既不是0也不是 $\infty$，那么说明存在从结点 $i$ 到结点 $j$ 的路径。

进一步，由于传递闭包不关心路径的长度，只关心存不存在路径，所以可以改进一下 Floyd-Warshall 算法，使用逻辑或操作($\or$)和逻辑与操作($\and$)来替换 Floyd-Warshall 算法中的算术操作 min 和 +。这样可以节省时间和空间，尽管时间复杂度同样是 $\Theta(n^3)$。如下图所示，Floyd-Warshall 算法被简化为用1表示存在路径，而用0表示不存在路径。

![FloydForTransitiveClosure](../static/image/FloydForTransitiveClosure.png)

