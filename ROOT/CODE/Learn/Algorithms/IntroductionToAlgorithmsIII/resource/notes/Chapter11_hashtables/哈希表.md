## 0 直接寻址表

寻址表必须能容纳全域U，即对每个可能的取值都要有一个单独的位置来存放，如下图所示：

![directAddress](../static/image/directAddress.png)

由于直接寻址表中每个关键字都对应唯一一个位置，所有不会出现冲突，但是对关键字的取值范围很大的情况会浪费很多存储空间。



## 1 散列表

### 1.1 散列表寻址方式

散列表中，对每个关键字调用散列函数，得到在散列表中的位置，如下图所示：

![hashTable1](../static/image/hashTable1.png)

由于散列函数可能会对不同的关键字计算出相同的散列值，所以散列表可能会发生冲突



### 1.2 解决冲突

#### 1.2.1 使用链表法解决冲突

链表法在散列表的每个位置设置一个指针，这个指针指向所有散列到该位置的关键字组成的链表，如下图：

![hashTable2](../static/image/hashTable2.png)

注意：这里的链表用的是双向链表，因为这样删除操作更快。例如删除关键字为 k~2~ 的节点，如果使用双链表，那直接修改它的左右指针地址即可，如果使用单链表，还需要去查找它左边节点的指针并修改该指针为 k~2~ 指向的地址。



#### 1.2.2 开放寻址法

见 [第4节](#4 开放寻址法)



### 1.3 散列表操作时间复杂度

平均情况：增删查操作都为 $\Theta (1)$

最坏情况：查找操作为 $\Theta(n)$（即所有关键字都被散列到同一个散列表的位置）；增删操作为$\Theta(1)$



## 3 散列函数

- 好的散列函数：散列函数应该将每个关键字尽量均匀的散列到散列表的每个位置上
- 关键字转换：如果关键字不是自然数，应该先转换为自然数在调用散列函数



### 3.1 除法散列法

将关键字[^1] 除以 m 取余数得到数字就是散列表中的位置(0 ~ m -1)，散列如下：

> $h(k) = k\space mod\space m$

注意：这里m的选取很重要，如果取值不当(例如2的幂)，很容易受到攻击，m的建议取值为：

> *一个不太接近2的整数次幂的素数*

例如下面这个散列函数：

> *例如：$h(k) = k\space mod\space 701$*



### 3.2 乘法散列法

分两步：

1. 用关键字 k 乘以常数 A (0<A<1)，取小数部分
2. 用 m 乘以这个值，再向下取整

散列函数如下：

> $h(k) = \lfloor m(kA\space mod\space 1)\rfloor$ 

A的选取，Knuth建议的取值如下：

> $A ≈ (\sqrt5 - 1)/2 = 0.6180339887...$



### *3.3 全域散列法

由于任何特定的散列函数都可能被散列攻击，即将所有关键字都散列到同一个位置。所以需要一个方法来避免这种攻击，唯一的办法就是随机的选择散列函数。这种方法就是全域散列[^2]  。

一个全域散列函数示例：

> $h_{ab}(k) = ((ak + b)\space mod\space p)\space mod\space m$

其中 p，m 是固定值，a ，b是随机值。

- p：一个足够大的素数[^3] ，使得关键字 k 都落在 0 到 p-1的范围(包括 0 和 p-1)
- m：散列表的大小，全域散列法中的 m 不必是素数，且显然 p > m
- a：随机值，$a\in Z_p，其中 Z_p表示集合 \{ 0,1, \cdots , p-1\}$
- b：随机值，$b\in Z_p^*，其中 Z_p^*表示集合 \{ 1,2, \cdots , p-1\}$

由于a的取值有p个，b的取值有p-1个，所以总共可选的散列函数有p(p-1)个。

## 4 开放寻址法

在开发寻址法中，所有元素都存放在散列表里，不存在桶链表，所以散列表中每个位置只能存放1个关键字，因此装载因子 α 不能超过1。

开放寻址法计算一个关键字 k 在散列表中的位置时，会进行探查，直到探查到一个可用位置(即未存储和删除过关键字的位置)，探查序列如下：

> $h(k,0), \space h(k,1) ,\cdots, \space h(k,m-1))$

该探查序列是$(0, 1, \space ... \space , m-1)$的一个排列。

由于散列表大小m可能小于关键字全域取值个数，所以如果散列表装满了继续再插入关键字会出现溢出的情况(其实这时装载因子 α 已经超过1了)，这时程序应该报错。

下面介绍3种探查方式



### 4.1 线性探查

散列函数如下：

> $h(k,i) = (h^{'}(k) + i) \space mod \space m，i=0,1,\cdots,m-1$

这里的 h'(k) 是一个普通散列函数。

线性探查的探查方式为：先对关键字 k 调用普通散列函数 h'(k) 计算散列位置，如果该位置已经被使用，则顺序查找下一个位置，如果查找到第 m-1 个位置还没成功，则继续从散列表的第0个位置开始查。

线性探查实现简单，但是存在问题，当散列表被逐渐填满时，探查时间可能会越来越长，尤其是当有很长的连续位置都被占用后，有时需要探查完这整一段连续位置才能找到空位置，这种问题称为**一次群集**。



### 4.2 二次探查

散列函数如下：

> $h(k,i)  = (h^{'}(k) + c_1i + c_2i^2) \space mod \space m$

同样，h'(k) 是一个普通散列函数，$i=0,1,\cdots,m-1$，c~1~ 和 c~2~ 是正常数。

注意：为了能探查整个散列表，c1， c2 和 m 的取值受到限制，因为不能出现 h(k, i) = h(k, i+1)这种情况，否则无法探查整个散列表。

二次探查的探查方式为：先对关键字 k 调用普通散列函数 h'(k) 计算散列位置，如果该位置已经被使用，则增加一个偏移量并对 m 取模来确定下一个查找位置，这个偏移量为 $c_1i + c_2i^2$ 。

可以看出二次探查比效果比线性探查好，但是当两个关键字的初始探查位置相同时，那这两个关键字的探查序列也是相同的，那么对所有初始探查位置相同的关键字，也会出现线性探查的问题，这种问题称为**二次群集**。





### 4.3 双重散列

散列函数如下：

> $h(k,i) = (h_1(k) + ih_2(k)) \space mod \space m$

其中 h~1~ 和 h~2~ 都是普通散列函数，$i=0,1,\cdots,m-1$。

同样要注意：为了能探查整个散列表，普通散列函数 h~2~(k) 受到限制，因为不能出现 h(k, i) = h(k, i+1)这种情况，否则无法探查整个散列表。

双重散列的探查方式为：先对关键字 k 调用普通散列函数 h~1~(k) 计算散列位置，如果该位置已经被使用，则增加一个偏移量并对 m 取模来确定下一个查找位置，这个偏移量为 $h_2(k)$。

由于每次探查增加的偏移量是以另一个散列方式(h~2~)依赖于关键字 k ，所以不会出现二次探查中的二次群集问题。

因此双重散列是用于开放寻址法的最好方法之一。



### 4.4 开放寻址散列的分析

在一个开放寻址散列表中：

- 假设装载因子 α < 1，且是均匀散列，一次不成功查找的探查次数至多为 $1/(1-\alpha)$
- 假设装载因子 α，且是均匀散列，插入一个元素的探查次数至多为 $1/(1-\alpha)$
- 假设装载因子 α < 1，且是均匀散列，一次成功查找的探查次数至多为 $\frac{1}{\alpha}ln\frac{1}{1-\alpha}$



## *5 完全散列

- 使用条件：关键字集合必须是静态的，即一旦各关键字存入散列表中，关键字集合就不再变化了[^4]。

- 特性：完全散列表能在最坏情况下在 O(1) 时间内访问每一个元素

- 散列方式：完全散列分两级进行散列：

  第一级散列函数：是从某一全域散列函数簇中仔细挑选出的一个散列函数。

  第二季散列函数：是一个精心设计并保证不会出现冲突的散列函数

在完全散列中，对每一个要查找的关键字，只需调用两级散列函数就能精确地查找到该关键字在散列表中的位置，而不需要链表法中的链表查找和开发寻址法中的探查。





[^1]: 或者关键字转换得到的自然数

[^2]: 自己推断，全域散列针对每个哈希表只会随机选择一次散列函数，然后后面这个哈希表一直都用这个散列函数。因为如果是每次插入新关键字都换一个散列函数，那查找的时候就不知道用哪个散列函数了
[^3]:个人认为，全域散列中的全域指的就是p，因为p就是全域的
[^4]:例如程序设计语言中的保留字集合，或者 CD-ROM 上的文件名集合