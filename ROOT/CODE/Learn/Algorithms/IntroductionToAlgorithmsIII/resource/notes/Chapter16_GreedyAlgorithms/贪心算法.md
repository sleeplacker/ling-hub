## 0 简介

贪心算法和动态规划方法同样都是用来求解最优化问题的，**贪心算法不保证能求出最优解**，但是对于很多问题能求出最优解。



## 1 活动选择问题

### 1.1 问题描述

有多个活动需要使用同一个教室，每个活动有开始和结束时间，求最多能满足几个活动在不重叠的时间占用这个教室。

### 1.2 动态规划解法

对于 $n$ 个活动的活动序列 $a_1,a_2,...,a_n$

定义 $c[i, j]$ 表示活动 $a_i $ 至活动 $a_j$ 这个活动序列的最大兼容活动数量$( 1>=i>=j>=n)$，假设活动 $a_k$ 在 $a_i$ 和 $a_j$ 之间，则

>  $c[i, j] = \max\{c[i, k-1] + c[k+1,j]\} + 1\space (其中k=i,i+1,...,j)$

有了上面的式子，可以用带备忘录的自顶向下方法进行求解，或者用自底向上方法求解。

### 1.3 贪心选择

动态规划方法中，每个子问题都依赖多个子问题的解，如果可以让每个子问题只依赖1个子问题的解，那么可以大大降低时间复杂度，贪心选择就是这样。

对于活动选择问题，可以使用贪心选择。在所有活动都按结束时间递增顺序排序的情况下，每次都选出与已选活动兼容[^1]的活动就能得到最优解。

### 1.4 设计贪心算法

**递归算法**

```java
	/**
	 * 递归算法求解活动选择问题
	 * 
	 * @param startTimes
	 * @param finishTimes
	 * @param m-已经处理完的活动位置
	 * @param n-活动总数
	 * @param result-记录活动选择结果
	 */
	private static void selectRecursively(int[] startTimes, int[] finishTimes, int k, int n, List result) {
		int m = k + 1;// 从下一个活动开始查找
		while (m <= n - 1 && startTimes[m] < finishTimes[k])
			++m;
		if (m <= n - 1) {// 查找成功
			result.add(m);// 加入新活动
			selectRecursively(startTimes, finishTimes, m, n, result);// 继续查找活动
		} else// 查找失败，结束查找
			return;
	}
```

**迭代算法**

```java
	/**
	 * 迭代算法求解活动选择问题
	 * 
	 * @param startTimes
	 * @param finishTimes
	 * @return
	 */
	private static List selectIteratively(int[] startTimes, int[] finishTimes) {
		List result = new ArrayList<>();
		result.add(0);// 第一个活动必选
		int n = startTimes.length;// 活动数量
		int k = 0;// k指向第一个活动
		for (int i = 1; i < n; ++i)
			if (startTimes[i] > finishTimes[k]) {// 查找兼容活动
				result.add(i);// 查找成功，将该活动加入结果集
				k = i;// 让k指向该活动
			}
		return result;
	}
```



[^1]: 兼容表示选出的活动不会与已选活动有时间冲突，选出的活动的开始时间在已选所有活动最后结束时间之后