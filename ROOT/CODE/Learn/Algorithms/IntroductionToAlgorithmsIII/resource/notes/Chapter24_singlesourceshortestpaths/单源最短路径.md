## 0 一些概念

**广度优先搜索与最短路径**

> 广度优先搜索算法就是一个求取最短路径的算法，但该算法只能用于无权重图，即每条边的权重都是单位权重的图。

**单源最短路径问题**

> 给定一个图 $G=(V, E)$，我们希望找到从给定源结点 $s \in V$ 到每个结点 $v \in V$ 的最短路径。

**最短路径的最优子结构**

> 最短路径算法通常依赖最短路径的一个重要性质：两个结点之间的一条最短路径包含着其他的最短路径。即**最短路径的子路径也是最短路径**。

**负权重的边**

单源最短路径问题可以包含权重为负值的边，但是不能包含从源结点可以到达的权重为负值的环路，因为可以在那个环路一直绕，使最短路径为 $-\infty$。

**环路**

最短路径中不应该包含任何环路(不管是权重为正还是为负的环路)，因此，如果最短路径包含 |V|个顶点，那么它最多包含|V|-1条边。

**最短路径的表示**

> 在通常情况下，我们不但希望计算出最短路径的权重，还希望计算出最短路径上的结点。给定图 $G=(V, E)$，对于每个结点 v，我们维持一个前驱结点 $v.\pi$。该前驱结点可能是另一个结点或者 NIL。将从结点 v 开始的前驱结点链反转过来，就是从 s 到 v 的一条最短路径。
>
> **最短路径树**
>
> 非形式化地说，最短路径树是一颗有根结点的树，该树包含了从源结点 s 到每个可以从 s 到达的结点的一条最短路径。需要指出的是，最短路径不一定是惟一的，最短路径树也不一定是唯一的。

**松弛操作**

我们使用 $v.d$ 来记录从源结点 s 到结点 v 的最短路径权重的上界，我们称 $v.d$ 为 s 到 v 的**最短路径估计**。通常在计算最短路径算法开始时，$v.d$ 都被设置为 $\infty$，松弛操作就是寻找适当的边来减小 $v.d$。

下图是对边(u, v)进行松弛操作的示例。图 a 中，因为松弛操作前有 $v.d > u.d + w(u, v)$，因而 $v.d$ 的值减小。图 b 中松弛操作前有 $v.d \leqslant u.d + w(u, v)$，因此松弛操作维持 v.d 的取值不变。

![PathWeightRelax](../static/image/PathWeightRelax.png)

注意：松弛是**唯一**导致最短路径估计和前驱结点发生变化的操作。

***最短路径和松弛操作的性质**

> **三角不等式性质**：对于任何边 $(u, v) \in E$，我们有 $\delta(s, v) \leqslant \delta(s, u) + w(u, v)$。
>
> **上界性质**：对于所有的结点 $v \in V$，我们总是有 $v.d \geqslant \delta(s, v)$。一旦 $v.d$ 的取值达到 $\delta(s, v)$，其值将不再发生变化。
>
> **非路径性质**：如果从结点 $s$ 到结点 $v$ 之间不存在路径，则总是有 $v.d  = \delta(s, v) = \infty$。
>
> **收敛性质**：对于某些结点 $u，v \in V$，如果 $s \leadsto u \rightarrow v$ 是图 G 中的一条最短路径，并且在对边 $(u, v)$ 进行松弛前的任意时间有 $u.d = \delta(s, u)$，则在之后的所有时间有 $v.d = \delta(s, v)$。
>
> **路径松弛性质**：如果 $p=<v_0, v_1, ... , v_k>$ 是从源结点 $s=v_0$ 到结点 $v_k$ 的一条最短路径，并且我们对 $p$ 中的边所进行松弛的次序为 $(v_0, v_1), (v_1, v_2), ... , (v_{k-1}, v_k)$，则 $v_k.d=\delta(s, v_k)$。该性质的成立与任何其他的松弛操作无关，即使这些松弛操作是对 $p$ 上的边所进行的松弛操作穿插进行的。
>
> **前驱子图性质：**对于所有几点 $v \in V$，一旦 $v.d = \delta(s, v)$，则前驱子图是一棵根结点为 $s$ 的最短路径树。

**概要**

Bellman-Ford 算法可以允许有负边权的边，并且可以侦测是否存在从源结点可以到达的权重为负值的环路。

Dijkstra 算法要求所有边的权重为非负值。



## 1 Bellman-Ford(贝尔曼福德) 算法

> Bellman-Ford 算法解决的是一般情况下的单源最短路径问题，在这里，边的权重可以为负值。给定带权重的有向图 $G=(V, E)$ 和权重函数 $w: E\rightarrow R$，Bellman-Ford 算法返回一个布尔值，如果返回 $FALSE$ 则表明有从源结点可达的权重为负的环路，否则返回 $TRUE$ 表示已经计算出最短路径和它们的权重。

**算法步骤**

- 步骤**化结点属性：对除源结点 $s$ 外的所有结点 $v$，令 $v.d = \infty$，$v.\pi = NIL$，$s.d = 0$。
- 对图的每条边进行 $|V| -1$ 次松弛操作
- 检查图中是否有权重为负值的环路

**算法执行过程**

如下图所示，源结点为 $s$，结点中的数值为该结点的 $d$ 值，加了阴影的边表示前驱值：如果边 $(u, v)$ 加了阴影，则 $v.\pi = u$。

需要注意的是，在对每条边进行 $|V| -1$ 轮松弛操作的过程中，每一轮松弛操作的顺序都是一样的，这里每一轮松弛操作对边的处理顺序为：$(t, x), \space (t, y),  \space (t, z),  \space (x, t),  \space (y, x),  \space (y, z),  \space (z, x),  \space (z, s),  \space (s, t),  \space (s, y)$。

- a：松弛前的状态，除 $s$ 外的所有结点 $v$，令 $v.d = \infty$，$v.\pi = NIL$，$s.d = 0$
- b：第一轮松弛，依次松弛前 8 条边，即$(t, x), \space (t, y),  \space (t, z),  \space (x, t),  \space (y, x),  \space (y, z),  \space (z, x),  \space (z, s)$ 的过程中，由于每条边的出发结点都是 $\infty$ ，且边的权重都是有限值，所以相加结果还是 $\infty$，没有改变前驱子图；当最后松弛边 $\space (s, t),  \space (s, y)$ 时，$t.d$ 和 $y.d$ 都被减小了，所以 $t.d = s.d + w(s, t) = 0 + 6 = 6$，$y.d = s.d + w(s, y) = 0 + 7 = 7$；同时改变 t 和 y 的前驱结点为 s，即 $t.\pi = s$，$y.\pi=s$
- c：第二轮松弛，和第一轮松弛一样，按照同样的顺序处理边。这一轮松弛发现了边 $(t, z)$ 和 $(y, x)$ 可以改变最短路径估值(同时也改变了前驱子图)。
- d：第三轮松弛，这一轮松弛发现了边 $(x, t)$ 可以改变最短路径估值(同时也改变了前驱子图)，注意这里 $t.\pi$ 原来是 s，现在被替换为了 x。
- e：第四轮松弛，这一轮松弛没有发现能够改变任何结点的最短路径估值的边。

![BellmanFord](../static/image/BellmanFord.png)

**为什么松弛的轮数为 |V| - 1**

因为在一个有 |V| 个结点的图中，最复杂的路径[^1]就是包含所有结点的简单路径，由于是简单路径，所以不存在环路，因此这条路径最多包含 |V|-1 条边。假设图中包含一条有 |V|-1 条边的最短路径，那么**第1轮松弛可以确定只包含1条边的最短路径[^2]**；同样，第2轮松弛可以确定包含2条边的最短路径；以此类推，直到在第 |V|-1 轮松弛中确定了包含|V|-1 条边的最短路径。 

然而，可能不存在包含|V|-1 条边的最短路径，例如上图中的例子就是，在最后一轮松弛操作中，每个结点的最短路径估值和前驱子图都未发生变化，因为它不包含|V|-1 条边的最短路径。

**时间复杂度**

$\Omicron(VE)$

 

[^1]: 这里的指包含结点数最多的路径
[^2]: 因为源结点 $s$ 的最短路径估值，即 $s.d = 0$，所以第1轮松弛可以确定 s 能到达的结点的最短路径估值(即d值)，所以可以确定边数为1的最短路径