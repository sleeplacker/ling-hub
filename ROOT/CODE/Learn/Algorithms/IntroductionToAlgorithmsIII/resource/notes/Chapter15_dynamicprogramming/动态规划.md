## 0 概述

### 0.1 使用场景

动态规划方法通常用来求解**最优化问题** ，且是求出一个最优解而不是唯一最优解。



### 0.2 动态规划通常的4个步骤

> 1. 刻画一个最优解的结构特征
> 2. 递归地定义最优解的值
> 3. 计算最优解的值，通常采用自底向上的方法
> 4. 利用计算出的信息构造一个最优解



## 1 钢条切割问题

### 1.1 问题描述

> 给定一段长度为 $n$ 英寸的钢条和一个价格表 $p_i(i=1,2,...,n)$，求切割钢条方案，使得销售收益$r_n$最大。
>

### 1.2 自顶向下递归实现

算法：假设第一刀的切割位置为 $i(i=1,2,...,n-1)$，然后对这 n-1 种情况分别递归地对剩下那段用同样的方式切割。

时间复杂度：$\Theta(2^n)$

### 1.3 动态规划方法实现

#### 1.3.1 带备忘的自顶向下法

在1.2节中普通的递归算法执行过程中，有很多子问题会重复计算，所以才导致时间复杂度为指数函数；如果将计算过的子问题进行保存，后面遇到同样子问题时就可以查询子问题，而不用重复计算，从而降低了时间复杂度。

#### 1.3.2 自底向上法

1.3.1节中需要判断一个子问题是否已经计算过，而自底向上法总是先计算小的子问题，再计算更大的子问题，所以计算更大的子问题时依赖的小的子问题都已经计算好了，这样就不需要判断子问题是否已经计算过，只需要直接取子问题的计算结果即可。





### 2 动态规划原理

适合应用动态规划方法求解的最优化问题应该具备两个要素：**最优子结构**和**子问题重叠** 。

#### 2.1 最优子结构

用动态规划方法求解最优化问题的第一步就是刻画最优化解的结构。如果**一个问题的最优解包含其子问题的最优解**，我们就称此问题具有最优子结构性质。



发掘最优子结构的通用模式

> 1. 证明问题最优解的第一个组成部分是做出一个选择，例如，选择钢条第一次切割的位置。做出这次选择会产生一个或多个待解的子问题。
> 2. 对于一个给定的问题，在其可能的第一步选择中，你假定已经知道哪种选择才会得到最优解。你现在并不关心这种选择具体是如何得到的，只是假定已经知道了这种选择。
> 3. 给定可获得最优解的选择后，你确定这次选择会产生哪些子问题，以及如何最好地刻画子问题空间。
> 4. 利用“剪切-粘贴”技术证明：作为构成原问题最优解的组成部分，每个子问题的解就是它本身的最优解。



最短路径和最长路径问题

- 无权最短路径问题有最优子结构，因为满足子问题无关性

- 无权最长路径问题无最优子结构，因为不满足子问题无关性，多个子问题之间共享了资源，而且有些子问题的组合得到的不是合法解

#### 2.2 子问题重叠

适合个动态规划方法求解的最优化问题应该具备的第二个性质是子问题空间必须足够“小”，即问题的递归算法会反复地求解相同的子问题。如果递归算法**反复求解相同的子问题**，我们就称最优化问题具有重叠子问题性质。与之相对的，适合用分治法求解的问题通常在递归的每一步都生成全新的子问题。动态规划算法通常这样利用重叠子问题性质：对每个子问题求解一次，将解存入一个表中，当再次需要这个子问题时直接查表，每次查表的代价为常亮时间。

#### 2.3 重构最优解和备忘

**重构最优解**：我们通常将每个子问题所做的选择存在一个表中，这样就不必根据代价值来重构这些信息。 

**备忘**：我们可以保持自顶向下的递归策略，同时达到与自底向上动态规划方法相似的效率。思路就是对**自然但低效**的递归算法加入备忘机制。与自底向上方法一样，我们维护一个表记录子问题的解，但仍保持递归算法的控制流程。带备忘机制的递归算法为每个子问题维护一个表项来保存它的解。每个表项的初始值设为一个特殊值，表示尚未填入子问题的解。当递归调用过程中第一次遇到子问题时，计算其解，并存入对应表项。随后每次遇到同一个子问题，只是简单地查表，返回其解。



### 3 最长公共子序列-LCS(longest-common-subsequence)

#### 3.1 问题描述

**子序列**

> 一个给定序列的子序列，就是将给定的序列中零个或多个元素去掉之后得到的结果。其形式化定义如下：
>
> 给定一个序列 $X=<x_1,x_2,...,x_m>$，另一个序列$Z=<z_1,z_2,...,z_k>$满足如下条件时称为 $X$ 的子序列，即存在一个严格递增的 $X$ 的下标序列$<i_1,i_2,...,i_k>$，对所有 $j=1,2,...,k$ ，满足 $x_{i_j}=z_j$。例如，$Z=<B,C,D,B>$ 是 $X=<A,B,C,B,D,A,B>$ 的子序列，对应的下标序列为 $<2,3,5,7>$ 。

**公共子序列**

> 给定两个序列 $X$ 和 $Y$，如果 $Z$ 既是 $X$ 的子序列，也是 $Y$ 的子序列，我们称它是 $X$ 和 $Y$ 的公共子序列。
>
> 例如 $X=<A,B,C,B,D,A,B>$，$Y=<B,D,C,A,B,A>$，那么序列 $<B,C,A>$ 是 $X$ 和 $Y$ 的公共子序列。但它不是 $X$ 和 $Y$ 的**最长公共子序列**(LCS)，因为它长度为3，而 $<B,C,B,A>$ 也是 X 和 Y 的公共子序列，其长度为4。$<B,C,B,A>$ 是 $X$ 和 $Y$ 的最长公共子序列，$<B,C,B,A>$ 也是，因为 $X$ 和 $Y$ 不存在长度大于等于 5 的公共子序列。

**最长公共子序列问题**

> 给定两个序列 $X=<x_1,x_2,...,x_m>$ 和 $Y=<y_1,y_2,...,y_n>$，求 $X$ 和 $Y$ 长度最长的公共子序列。

#### 3.2 刻画LCS的最优子结构

**前缀表示法**

> 给定一个序列 $X=<x_1,x_2,...,x_m>$，定义 $X$ 的第 $i$ 前缀为 $X_i=<x_1,x_2,...,x_i>$。例如，若 $X=<A,B,C,B,D,A,B>$，则 $X_4=<A,B,C,B>$，$X_0$ 为空串。

**LCS的最优子结构定理**

> 令 $X=<x_1,x_2,...,x_m>$ 和 $Y=<y_1,y_2,...,y_n>$ 为两个序列，$Z=<z_1,z_2,...,z_k>$ 为 $X$ 和 $Y$ 的任意 LCS。
>
> 1. 如果 $x_m=y_n$，则 $z_k=x_m=y_n$ 且 $Z_{k-1}$ 是 $X_{m-1}$ 和 $Y_{n-1}$ 的一个LCS。
> 2. 如果 $x_m≠y_n$，那么 $z_k≠x_m$ 意味着 $Z$ 是 $X_{m-1}$ 和 $Y$ 的一个LCS。
> 3. 如果 $x_m≠y_n$，那么 $z_k≠y_n$ 意味着 $Z$ 是 $X$ 和 $Y_{n-1}$ 的一个LCS。

#### 3.3 观察重叠子问题性质

为了求解 $X_i$ 和 $Y_j$ 的 LCS，如果 $x_i≠y_j$，那么需要求 $X_{i-1}$ 与 $Y_j$ 的 LCS 和 $X_i$ 与 $Y_{j-1}$ 的 LCS，而这两个过程都会用到 $X_{i-1}$ 与 $Y_{j-1}$ 的 LCS 这个子问题，所以满足重叠子问题性质。

