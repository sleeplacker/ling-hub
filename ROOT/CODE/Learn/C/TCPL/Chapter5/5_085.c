#include <stdio.h>

int main()
{
    int a[10], i, *p;
    for (i = 0; i < 10; ++i)
        a[i] = i + 1;
    long *lp;

    /* 数组变量a的地址等于数组a中首个元素的地址 */
    printf("数组变量 a 的地址：%ld\n", a);
    printf("数组首个元素的地址：%ld\n", &a[0]);

    /* 数组变量a可以赋值给相应类型的指针变量 */
    p = a;
    printf("*p = %d\n", *p);
    printf("*(++p) = %d\n", *(++p)); /* ++p表示p指向下一个元素 */
    printf("p[2] = %d\n", p[2]);     /* 可以对指针变量使用下标运算 */

    /* 指针和数组变量的区别 */
    printf("*a = %d\n", *a); /* 数组变量可以和指针变量一样使用*运算符 */
    // printf("*(++a) = %d\n", *(++a));/* 编译报错：但是数组变量不能使用++运算符，而指针变量可以 */

    /* long指针指向int元素：会出现异常情况 */
    lp = a;                    /* 编译通过，有警告 */
    printf("*lp = %d\n", *lp); /* 打印首个元素，正确 */
    /* 下面一行打印了第3个int元素，而不是第2个，因为lp指向long类型占8字节，所以lp+1指向8字节后的地址 */
    printf("*(lp+1) = %d\n", *(lp + 1));

    /* 指针前移 */
    p = &a[5];
    printf("*p = %d\n", *p);
    printf("*(p-2) = %d\n", *(p - 2));
    /*
    下面一行的打印结果：-2067819328 
    指针前移至超出数组界限时，不会有编译错误
    或者运行错误，但是指向的地方是不合法的，
    而且是危险的，因为从再下面两行可以看出
    这个不合法的地址的数据是可以被修改的
    */
    printf("*(p-7) = %d\n", *(p - 7));
    *(p - 7) = 100;
    printf("被修改后的 *(p-7) = %d\n", *(p - 7));
    return 0;
}