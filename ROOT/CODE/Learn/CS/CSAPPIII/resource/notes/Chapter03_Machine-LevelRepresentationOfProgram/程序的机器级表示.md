## 1 处理器和指令集

**处理器**

例如：8086、i386、Pentium(奔腾) 和 Core i7 这些芯片型号。

**指令集**

x86-64 指令集：它是现在笔记本电脑和台式机中最常见处理器的机器语言，也是驱动大型数据中心和超级计算机的最常见处理器的机器语言。这种语言的历史悠久，开始于 Intel 公司 1978 年的第一个 16 位处理器，然后扩展为 32 位，最近又扩展到 64 位。

IA32：x86-64 的 32 位前身，是 Intel 在 1985 年提出的。几十年来一直是 Intel 的机器语言之选。今天出售的大多数 x86 微处理器，以及这些机器上安装的大多数操作系统，都是为运行 x86-64 设计的。不过，它们也可以向后兼容执行 IA32 程序。所以，很多应用程序还是基于 IA32 的。除此之外，由于硬件或系统软件的限制，许多已有的系统不能执行 x86-64。IA32 仍然是一种重要的机器语言。



## 2 程序编码

**gcc 编译过程**

> 以下面的命令为例：
>
> `linux> gcc -0g -o p p1.c p2.c`
>
> 1. C 预处理器扩展源代码，插入所有用 #include 命令指定的文件，并扩展所有用 #define 声明指定的宏。
> 2. 编译器产生两个源文件的汇编代码，名字分别为 p1.s 和 p2.s。
> 3. 汇编器会将汇编代码转化成二进制目标代码文件 p1.o 和 p2.o。目标代码是机器代码的一种形式，它包含所有指令的二进制表示，但是还没有填入全局值的地址。
> 4. 链接器将两个目标代码文件与实现库函数(例如 printf) 的代码合并，并产生最终的可执行代码文件 p(由命令行指示符 -o p 指定的)。

### 2.1 机器级代码

**机器级编程的抽象**

> 1. 用 **指令集体系结构或指令集架构(Instruction Set Architecture，ISA)** 来定义机器级程序的格式和行为，它定义了处理器状态、指令的格式，以及每条指令对状态的影响。大多数 ISA，包括 x86-64，将程序的行为描述成**好像每条指令都是按顺序执行的**，一条指令结束后，下一条再开始。
> 2. 机器级程序使用的内存地址是 **虚拟地址**，提供的内容模型**看上去是一个非常大的字节数组**。

**机器代码会用到的寄存器**

- **程序计数器**：通常称为 “PC”，在 x86-64 中用 %rip 表示。程序计数器给出将要执行的下一条指令在内存中的地址。
- **整数寄存器文件**：包括 16 个命名的位置，分别存储 64 位的值。这些寄存器可以存储地址或整数数据。有的寄存器被用来记录某些重要的程序状态，而其他的寄存器用来保存临时的数据，例如过程的参数和局部变量，以及函数的返回值。
- **条件码寄存器**：保存着最近执行的算术或逻辑指令的状态信息。它们用来实现控制或数据流中的条件变化，比如说用来实现 if 和 while 语句。
- **向量寄存器**：可以存放一个或多个整数或浮点数值。

### 2.2 gcc 编译命令

**生成汇编代码**

`linux> gcc -0g -S mstore.c`

**生成二进制目标文件**

`linux> gcc -0g -c mstore.c`

**反汇编二进制目标文件**

`linux> objdump -d mstore.o`

**直接将多个源文件生成可执行文件**

`linux> gcc -0g -o prog main.c mstore.c`

**反汇编可执行文件**

`linux> objdump -d prog`

### 2.3 ATT 与 Intel 汇编代码格式

> ATT(根据 “AT&T” 命名的，AT&T 是运营贝尔实验室多年的公司) 格式的汇编代码，是 GCC、OBJDUMP 和其他一些我们使用的工具的**默认格式**。其他一些编程工具，包括 Microsoft 的工具，以及来自 Intel 的文档，其汇编代码都是 Intel 格式的。这两种格式在许多方面有所不同。
>
> GCC 可以使用下面的命令生成 Intel 格式的代码：
>
> `linux> gcc -0g -S -masm=intel mstore.c`
>
> **Intel 和 ATT 格式汇编代码的区别** (具体参考第118页)
>
> - Intel 代码省略了指示大小的后缀。
> - Intel 代码省略了寄存器名字前面的 ‘%’ 符号。
>
> - Intel 代码用不同的方式来描述内存中的位置，例如是 ’QWORD PTR [rbx]' 而不是 ‘(%rbx)’。
> - 在带有多个操作数的指令情况下，列出操作数的顺序相反。

## 3 数据格式

**Intel 数据类型对字定义**

> 由于最初的 Intel 处理器是 16 位体系结构，所以 “字” 表示 16 位数据类型。因此，称 32 位数为 “双字”，称 64 位数为 “四字”。

下图是 C 语言中的数据类型在 x86-64 中的大小

![SizesInx86-64](../static/image/SizesInx86-64.png)

## 4 访问信息

> 一个 x86-64 的中央处理单元(CPU)包含一组 16 个存储 64 位值的通用目的寄存器。这些寄存器用来存储整数数据和指针。

下图显示了这 16 个寄存器

![IntegerRegisters](../static/image/IntegerRegisters.png)

可以根据图中的寄存器名字来访问寄存器的一部分或整个寄存器，字节级操作可以访问最低的字节，16 位操作可以访问最低的 2 个字节，32 位操作可以访问最低的 4 个字节，而 64 位操作可以访问整个寄存器。

**生成小于 8 字节结果的指令**

> 对于生成小于 8 字节结果的指令，寄存器中剩下的字节会怎么样，对此有两条规则：
>
> - 生成 1 字节和 2 字节数字的指令会保持剩下的字节不变
> - ==生成 4 字节数字的指令会把高位 4 个字节置为 0==。这条规则是作为从 IA32 到 x86-64 的扩展的一部分而采用的。

### 4.1 操作数指示符

**三种操作数**

> 1. **立即数**：用来表示常数值。**在 ATT 格式的汇编代码中**，立即数的书写方式是 ‘\$’ 后面跟一个用标准 C 表示法表示的整数，比如，\$-577 或 \$0x1F。不同的指令运行的立即数值范围不同，汇编器会自动选择最紧凑的方式进行数值编码。
>
> 2. **寄存器**：它表示某个寄存器的内容，16 个寄存器的低 1 字节、2 字节、4 字节或 8 字节中的一个作为操作数，这些字节数分别对应于 8 位、16 位、32 位或 64 位。在下图中，我们用返回 $r_a$ 来表示任意寄存器 a，用引用 $R[r_a]$ 来表示它的值，这是将寄存器集合看出一个数字 R，用寄存器标识符作为索引。
> 3. **内存引用**：它会根据计算出来的地址(通常称为有效地址)访问某个内存位置。因为内存看成一个很大的字节数组，我们用符号 $M_b[Addr]$ 表示对存储在内存中从地址 Addr 开始的 b 个字节值的引用。为了简便，我们通常省去下标 b。

下图展示了所有的操作数格式

![OperandForms](../static/image/OperandForms.png)

**内存寻址方式**

最一般的寻址方式是上图中的最后一种形式，即 Imm(r_b, r_i, s)，有效地址计算方式为：$Imm+R[r_b]+R[r_i] \centerdot s$。需要注意的是：==这里的 s 只能取 1、2、4 或 8==。

