## 1 信息存储

> 大多数计算机使用 8 位的块，或者*字节*，作为最小的可寻址的内存单位，而不是访问内存中单独的位。机器级程序将内存视为一个非常大的字节数组，称为**虚拟内存**。内存的每个字节都由一个唯一的数字来标识，称为它的**地址**，所有可能地址的集合就称为**虚拟地址空间**。

### 1.1 字数据大小

> 每台计算机都有一个**字长**，指明指针数据的**标称大小**(指标准大小)。因为虚拟地址是以这样的一个字来编码的，所以字长决定的最重要的系统参数就是**虚拟地址空间的最大大小**。也就是说，对于一个长为 $w$ 位的机器而言，虚拟地址的范围为 $0\thicksim 2^w-1$，程序最多访问 $2^w$ 个字节。简而言之，就是**计算机的字长决定了寻址范围**。

**32 位程序和 64 位程序**

一个程序是 32 位还是 64 位和运行它的机器无关，区别在于该程序是如何编译的。例如，若使用下面命令编译一个 C 程序

`linux> gcc -m32 prog.c`

那么该程序可以在 32 位或 64 位机器上正确运行。若使用下面命令编译同样一个 C 程序

`linux> gcc -m64 prog.c`

那它只能在64位机器上运行。



**C 语言中的数据类型**

下图展示了 C 语言中的部分数据类型。可以看到，对于有些数据类型，在 32 位和 64 位机器上占用不同的字节数，例如 long 类型和 unsigned long 类型，还有 char* 类型，因为指针类型都是**全字长**的。

![DataTypeInC](../static/image/DataTypeInC.png)

**关于 long 类型**

在 Windows 64 下，尽管将程序编译为 64 为程序，但是 long 类型仍然是 4 字节，原因如下：

> **一.c语言数据占用字节**
>
> 32位：char 1   short 2  int 4 long 4 long long 8
>
> 64位：char 1  short 2   int 4 long 8 long long 8
>
> **二.可能原因 编译器的数据模型**
>
> Datetype LP64  ILP64  LLP64  ILP32   LP32
>
> char      8      8     8       8      8
>
> short      16    16    16      16     16
>
> int        32    64    32      32     16
>
> long       64    64    32      32     32 
>
> long long   64
>
> pointer     64    64     64      32     32
>
> 一般情况下windows64位一般使用LLP64模型
>
> 64位Unix,Linux使用的是LP64模型



### 1.2 寻址和字节顺序

> 对于跨越**多个字节**的程序对象，我们必须建立两个规则：这个**对象的地址**是什么，以及在内存中**如何排列**这些字节。
>
> 在几乎所有的机器上，多字节对象都被存储为**连续的**字节序列，对象的地址为所使用字节中最小的地址。例如：有一个 int 类型的数据对象 x，它的地址为 0x100，由于 x 占用 4 个字节，所以 x 被存储在内存的 0x100、0x101、0x102 和 0x103 位置。

**大端法和小端法**



![BigEndianAndLittleEndlian](../static/image/BigEndianAndLittleEndlian.png)