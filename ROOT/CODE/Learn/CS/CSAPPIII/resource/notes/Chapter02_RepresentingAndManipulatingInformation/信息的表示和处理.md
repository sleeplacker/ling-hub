## 1 信息存储

> 大多数计算机使用 8 位的块，或者*字节*，作为最小的可寻址的内存单位，而不是访问内存中单独的位。机器级程序将内存视为一个非常大的字节数组，称为**虚拟内存**。内存的每个字节都由一个唯一的数字来标识，称为它的**地址**，所有可能地址的集合就称为**虚拟地址空间**。

### 1.1 字数据大小

> 每台计算机都有一个**字长**，指明指针数据的**标称大小**(指标准大小)。因为虚拟地址是以这样的一个字来编码的，所以字长决定的最重要的系统参数就是**虚拟地址空间的最大大小**。也就是说，对于一个长为 $w$ 位的机器而言，虚拟地址的范围为 $0\thicksim 2^w-1$，程序最多访问 $2^w$ 个字节。简而言之，就是**计算机的字长决定了寻址范围**。

**32 位程序和 64 位程序**

一个程序是 32 位还是 64 位和运行它的机器无关，区别在于该程序是如何编译的。例如，若使用下面命令编译一个 C 程序

`linux> gcc -m32 prog.c`

那么该程序可以在 32 位或 64 位机器上正确运行。若使用下面命令编译同样一个 C 程序

`linux> gcc -m64 prog.c`

那它只能在64位机器上运行。



**C 语言中的数据类型**

下图展示了 C 语言中的部分数据类型。可以看到，对于有些数据类型，在 32 位和 64 位机器上占用不同的字节数，例如 long 类型和 unsigned long 类型，还有 char* 类型，因为指针类型都是**全字长**的。

![DataTypeInC](../static/image/DataTypeInC.png)



### 1.2 寻址和字节顺序

> 对于跨越**多个字节**的程序对象，我们必须建立两个规则：这个**对象的地址**是什么，以及在内存中**如何排列**这些字节。
>
> 在几乎所有的机器上，多字节对象都被存储为**连续的**字节序列，对象的地址为所使用字节中最小的地址。例如：有一个 int 类型的数据对象 x，它的地址为 0x100，由于 x 占用 4 个字节，所以 x 被存储在内存的 0x100、0x101、0x102 和 0x103 位置。

**大端法和小端法**



![BigEndianAndLittleEndlian](../static/image/BigEndianAndLittleEndlian.png)