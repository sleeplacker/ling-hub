## 1 数字签名要解决的问题

首先从消息认证码说起：

> Alice和Bob在网络中传输消息时，数据包可能在网络中间被截获，然后被篡改再发给对方。
>
> 消息认证码可以防止消息被篡改，大体实现原理如下：
>
> 1. Alice和Bob约定一个秘钥，双方都保存该秘钥
> 2. Alice准备要发送给Bob的消息，并计算消息的散列值，并用上面约定好的秘钥加密该散列值，得到MAC
> 3. Alice消息和MAC发给Bob
> 4. Bob收到Alice发送的消息和MAC后，使用上面约定的秘钥对消息以同样的方式计算MAC值，然后和Alice发送MAC比较是否相等，如果不相等，说明消息在传输过程中被篡改，消息作废。

消息认证码的问题：无法防抵赖。因为发送和接收双方都是用的相同的秘钥，所以当Alice发送了消息和MAC给Bob时，Alice可以抵赖说：这个消息和MAC不是我发的，而是Bob自己发给自己的，因为Bob也知道秘钥。

数字签名要解决的就是上面的问题。



## 2 数字签名运作流程

下面是使用数字签名的一个示例：

>1. Alice生成RSA秘钥对，并将公钥发送给Bob
>2. Alice准备发送消息，并计消息算散列值
>3. Alice使用上面生成的RSA私钥对消息散列值加签，得到签名
>4. Alice将消息和签名发送给Bob
>5. Bob收到消息后也计算消息的散列值，并使用Alice的RSA公钥对签名进行解签，得到消息散列值，并和签名自己计算的散列值比较，如果不一样，说明消息被篡改。

因为第3步中Alice对消息加签使用的是自己私钥，而Bob和其他人都没有Alice的私钥，所以这条消息可以确定是Alice发的，这样就做的了防抵赖。



## 3 证书-合法的公钥

数字签名面临的一个问题：Alice发送给Bob的公钥可能不是Alice的，即不是合法的公钥，这种情况通常出现在中加入攻击中，下面是中间人攻击的一个列子：

> 1. Alice发送自己的RSA公钥给Bob
> 2. 结果被中间人Mallory截获，并将自己的RSA公钥发送给了Bob
> 3. Alice发送消息和数字签名给Bob
> 4. 结果又被中间人Mallory截获，然后Mallory将Alice的消息进行篡改，然后将篡改后的消息和使用自己的私钥加签得到数字签名一并发送给Bob
> 5. Bob收到的消息其实是Mallory发的，而不是Alice发的，但是验签确能通过，因为Bob保存的公钥就是Mallory的

要解决上面中间人攻击的问题，就需要用到证书，下面是一个使用证书的列子：

> 1. Bob生成秘钥对，并将私钥自行妥善保管，这里秘钥对也可以由认证机构代为生成
> 2. Bob在认证机构Trent注册自己的公钥，Trent收到Bob的公钥后，会确认所收到的公钥是否为Bob本人所有(例如当面认证或通过身份证明来确认)
> 3. 认证机构Trent用自己的私钥对Bob的公钥加上数字签名并生成证书，这里认证机构Trent事先已经生成了自己的秘钥对
> 4. 现在Alice需要向Bob发送密文，所以Alice从Trent出获得带有认证机构Trent的数字签名的Bob的公钥，其实就是证书，证书中包含Bob的公钥和Trent对公钥签署的数字签名
> 5. Alice使用认证机构Trent的公钥对证书中的数字签名进行验签(这个过程和第2节中的数字签名一样，只不过这里签名和验签的对象是公钥，而第2节中是消息)，确认Bob的公钥的合法性，到这里，Alice得到了合法的Bob的公钥
> 6. Alice用Bob的公钥加密消息并发送给Bob
> 7. Bob使用自己的私钥解密密文得到Alice的消息

上面的例子中，Alice拿到了Bob合法的公钥后是用来对消息进行加密的，其实同样可以用来对Bob的数字签名进行验签。